;bibliotecas necessarias
(require (lib "swgr.scm" "user-feup"))
(require (lib "tabuleiro.scm" "user-feup"))


;janela do jogo
(janela 1190 720 "schemesnake alpha")


(define tabjogo (tabuleiro 10 690 30 39 22))

;cria posicao inicial cobra
(define init-snake (list (cons 0 2) (cons 1 2) (cons 1 3) (cons 1 4) (cons 1 5) (cons 2 5)))

;criação de um novo objeto
(define novo-objeto
  (lambda (snake)
    ;gera duas coordenadas aleatórias para o objeto
    (let ((coord (cons (random (cel-x tabjogo)) (random (cel-y tabjogo)))))
    
     ;se a posição do novo objeto coincidir com a serpente, gera novascoordenadas
     (if (member coord snake)
         (novo-objeto snake)
         (begin
    ;cria o objeto na célua indicada (símbolo e fundo)
    (celula tabjogo (car coord) (cdr coord) 'l 18)
    (celula tabjogo (car coord) (cdr coord) 'x 26)
      
      coord)))))

(define objeto (novo-objeto init-snake))

(define pontalta 0)
(define pont 0)
(define pontalta-pos (list 1120 10))
(define pont-pos (list 820 10))

;desenha legenda
(define init-legenda
 (lambda ()
   
   (move (list 10 698))
   (cor 0)
   (desenha-txt "schemesnake alpha build                                  Fundamentos da Programação  FEUP  2017                                 Programado por Tiago Ribeiro")
   
   
   (move (list 10 10))
   (desenha-txt "Legenda:     ")
   
   (cor 18)
   (desenha-txt (symbol->string 'X))
   (cor 0)
   (desenha-txt " - Item Normal      ")
   
   (cor 18)
   (desenha-txt (symbol->string 'X))
   (cor 0)
   (desenha-txt " - Item Normal      ")
   
   (cor 18)
   (desenha-txt (symbol->string 'X))
   (cor 0)
   (desenha-txt " - Item Normal      ")
   
   (desenha-txt "                        Pontuação:        ")
   (desenha-txt "                    Pontuação Máxima:    ")))

(define load-pontalta 
  (lambda ()
         (if (not(file-exists? "snakescheme_score.txt"))
         (letrec ((novo-ficheiro (open-output-file "snakescheme_score.txt")))
           (display 0 novo-ficheiro)
           (close-output-port novo-ficheiro)))
    (set! pontalta (read(open-input-file "snakescheme_score.txt")))
    (move pontalta-pos)
    (cor 0)
   (desenha-txt (number->string  pontalta))))     



;desenha high-score
(define atualiza-pontuacao
 (lambda (pontos)
   (move pont-pos)
   (cor 26)
   (desenha-txt (number->string  pont))
   
   (move pont-pos)
   (cor 0)
   (set! pont (+ pont pontos))
   (desenha-txt (number->string  pont))
   (if (> pont pontalta)
       (begin
         (move pontalta-pos)
         (cor 26)
         (desenha-txt (number->string (- pont pontos)))
         
         (move pontalta-pos)
         (cor 0)
         (desenha-txt (number->string  pont))))))

;procedimento de inicio do jogo
(define jogo
  (lambda (snake)
    ;incialização da cobra
    (celulas tabjogo snake 'l 0 0)
    
    (load-pontalta)    
    (init-legenda)
    (atualiza-pontuacao 0)
    
    (letrec ((snake init-snake)
             (direcao 'right)
             ;procedimento auxiliar responsável por ler o teclado e atualizar recusivamente o jogo
             (principal
              (lambda (snake)
                
                  
                ;intervalo de tempo para controlar a velocidade do jogo
                (sleep 0.04)
                ;deteção da tecla pressionada no momento
                (let ((temp #t)
                      (tecla (tecla-pressionada #f)))
                  
                ;mudança de direção apenas se for pressionada uma tecla
                (if (not (void? tecla))
                    ;impede que o jogador vire a cobra contra si mesma (180 graus)
                    (if (not(or (and (eq? direcao 'right) (eq? tecla 'left))
                            (and (eq? direcao 'left) (eq? tecla 'right))
                            (and (eq? direcao 'up) (eq? tecla 'down))
                            (and (eq? direcao 'down) (eq? tecla 'up))))
                    (set! direcao tecla)))
                  
                  
                  ;chamada pelo procedimento que calcula a nova cobra após um novo instante do jogo
                  (set! temp (snake-move snake direcao))
                  (if (not (eq? temp #f)) (set! snake temp)) 
                  
                  ;termina o jogo em caso de derrota
                  (if (not(eq? temp #f))    
                  ;repete o cilo principal do jogo
                  (principal snake) ;(begin (tecla-pressionada #t) (jogo snake))
                  (begin
                  (if (> pont pontalta)
                      (letrec ((guarda-pontalta (open-output-file "snakescheme_score.txt" 'replace)))
                  (display pont guarda-pontalta)
                  (close-output-port guarda-pontalta)))
                  (sleep 3)
                  (tecla-pressionada #t)
                  (fecha-janela)))))))
             (principal snake))))
             
             



(define snake-move
  (lambda (snake direcao)  
    
    (let* (;eliminação do último pixel na nova cobra
           (snake-next (list-tail snake 1))
           ;obtenção das coordenadas do primeiro pixel da cobra (atual)
             (x (car (list-ref snake-next (sub1 (length snake-next)))))
             (y (cdr (list-ref snake-next (sub1 (length snake-next))))))
      
      ;cálculo do primeiro pixel da nova cobra de acordo com a direção do jogo
      (cond
        ((eq? direcao 'right) (set! x (add1 x)))
        ((eq? direcao 'left) (set! x (sub1 x)))
        ((eq? direcao 'up) (set! y (sub1 y)))
        ((eq? direcao 'down) (set! y (add1 y))))
      
      ;se a cobra colidir com algum dos limites do tabuleiro, reaparece no limite oposto
      (cond ((= x (cel-x tabjogo)) (set! x 0))
            ((< x 0) (set! x (sub1 (cel-x tabjogo))))
            ((= y (cel-y tabjogo)) (set! y 0))
            ((< y 0) (set! y (sub1 (cel-y tabjogo)))))
      
      ;para o jogo se a cobra tiver batido em si mesmo
      (if (member (cons x y) snake)
          ;escreve mensagem fim de jogo
          (begin
            (cor 18)
            (desenha-txt "Game Over")
            #f)
          
          (begin
            
      ;adição do novo pixel à lista da cobra
      (append! snake-next (list (cons x y)))
     
            
      ;atualização dos pixeis em questão (primeiro e último)
      (celula tabjogo x y 'l 0)
      ;se a serpente apanhar o objeto, gera um novo
      (if (and (eq? (car objeto) x) (eq? (cdr objeto) y))
          (begin
            ;cancela a eliminação do ultimo pixel, aumentando o tamanho da cobra
            (set! snake-next (append (list (car snake)) snake-next))
            (set! objeto (novo-objeto snake-next))
            (atualiza-pontuacao 1)) 
          ;elimina o ultimo pixel da serpente
          (celula tabjogo (caar snake) (cdr (car snake)) 'l 26))
      
      ;retorno da nova lista da cobra
      snake-next)))))




(jogo init-snake)